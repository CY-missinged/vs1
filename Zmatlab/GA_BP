% 清空环境变量
clc;
clear;
close all;

%% 样本数据生成
jizhanid=load('anchorCfg.mat');
data=load('area_sample_test.mat');
location=zeros(499,83);
location1={'A0000','A83F2','A8418','A8420','A841C'};
[al,bl]=size(location1);
for ii=1:499
    [shoudaogeshu,useless]=size(data.blink_frame(ii).anchor_array);
    for ii2=1:shoudaogeshu
        for kk=1:82
            if strcmp(jizhanid.anchorCfg{kk,1},data.blink_frame(ii).anchor_array{ii2, 1}.id)
                location(ii,kk)=data.blink_frame(ii).anchor_array{ii2, 1}.csi(2);
            end
        end
    end
    for ii3=1:bl
        if strcmp(location1(ii3),data.detected_area{ii, 1})
            location(ii,83)=ii3;
        end
    end
end

rowrank = randperm(size(location, 1)); % 随机打乱行
locationend = location(rowrank, :);%%按照rowrank打乱矩阵的行数
[a22,b22]=size(locationend);

for i=1:a22 %二值化
    for j=1:b22-1
        if locationend(i,j)~=0
            locationend(i,j)=1;
        end
    end
end
            
%% BP算法

%输入数据
data=locationend;

%训练预测数据
data_train=data(1:220,1:83);
data_test=data(221:499,1:83);

input_train=data_train(:,1:82)';
output_train=data_train(:,83)';

input_test=data_test(:,1:82)';
output_test=data_test(:,83)';

%数据归一化
[inputn,mininput,maxinput,outputn,minoutput,maxoutput]=premnmx(input_train,output_train); %对p和t进行字标准化预处理 
net=newff(minmax(inputn),[10,1],{'tansig','purelin'},'trainlm');

net.trainParam.epochs=1000;
net.trainParam.lr=0.1;
net.trainParam.goal=0.001;
net.trainParam.show=200;

%网络训练
net=train(net,inputn,outputn);
%数据归一化
inputn_test = tramnmx(input_test,mininput,maxinput);
an=sim(net,inputn_test);
test_simu=postmnmx(an,minoutput,maxoutput);


Yn=test_simu;
Yn=round(Yn); 
figure                       %绘图
plot(Yn,'r*-')                %绘制预测值曲线
hold on                       %继续绘图
plot(output_test,'bo-')                  %实际值曲线
legend('BP预测值','实际值')      %图例
wucha1=ones(1,79);             %BP时预测误差
for ii1=1:79
    wucha1(ii1)=(Yn(ii1)-output_test(ii1));
end
figure
plot(wucha1,'b^-')
% %% GABP算法
% %% 网络结构建立
% %读取数据
% data=locationend;
% 
% %节点个数
% inputnum=10;
% hiddennum=65;
% outputnum=1;
% data_train=data(1:420,1:83);
% data_test=data(421:499,1:83);
% 
% input_train=data_train(:,1:82)';
% output_train=data_train(:,83)';
% 
% input_test=data_test(:,1:82)';
% output_test=data_test(:,83)';
%
% 
% %% 遗传算法参数初始化
% maxgen=10;                         %进化代数，即迭代次数
% sizepop=6;                        %种群规模
% pcross=[0.3];                       %交叉概率选择，0和1之间
% pmutation=[0.1];                    %变异概率选择，0和1之间
% 
% %节点总数
% numsum=inputnum*hiddennum+hiddennum+hiddennum*outputnum+outputnum;
% 
% lenchrom=ones(1,numsum);        
% bound=[-3*ones(numsum,1) 3*ones(numsum,1)];    %数据范围
% 
% %------------------------------------------------------种群初始化--------------------------------------------------------
% individuals=struct('fitness',zeros(1,sizepop), 'chrom',[]);  %将种群信息定义为一个结构体
% avgfitness=[];                      %每一代种群的平均适应度
% bestfitness=[];                     %每一代种群的最佳适应度
% bestchrom=[];                       %适应度最好的染色体
% %初始化种群
% for i=1:sizepop
%     %随机产生一个种群
%     individuals.chrom(i,:)=Code(lenchrom,bound);    %编码（binary和grey的编码结果为一个实数，float的编码结果为一个实数向量）
%     x=individuals.chrom(i,:);
%     %计算适应度
%     individuals.fitness(i)=fun(x,inputnum,hiddennum,outputnum,net,inputn,outputn);   %染色体的适应度
% end
% 
% %找最好的染色体
% [bestfitness, bestindex]=min(individuals.fitness);
% bestchrom=individuals.chrom(bestindex,:);  %最好的染色体
% avgfitness=sum(individuals.fitness)/sizepop; %染色体的平均适应度
% % 记录每一代进化中最好的适应度和平均适应度
% trace=[avgfitness bestfitness]; 
%  
% %% 迭代求解最佳初始阀值和权值
% % 进化开始
% for i=1:maxgen
%     
%     % 选择
%     individuals=Select(individuals,sizepop); 
%     avgfitness=sum(individuals.fitness)/sizepop;
%     %交叉
%     individuals.chrom=Cross(pcross,lenchrom,individuals.chrom,sizepop,bound);
%     % 变异
%     individuals.chrom=Mutation(pmutation,lenchrom,individuals.chrom,sizepop,i,maxgen,bound);
%     
%     % 计算适应度 
%     for j=1:sizepop
%         x=individuals.chrom(j,:); %解码
%         individuals.fitness(j)=fun(x,inputnum,hiddennum,outputnum,net,inputn,outputn);   
%     end
%     
%   %找到最小和最大适应度的染色体及它们在种群中的位置
%     [newbestfitness,newbestindex]=min(individuals.fitness);
%     [worestfitness,worestindex]=max(individuals.fitness);
%     % 代替上一次进化中最好的染色体
%     if bestfitness>newbestfitness
%         bestfitness=newbestfitness;
%         bestchrom=individuals.chrom(newbestindex,:);
%     end
%     individuals.chrom(worestindex,:)=bestchrom;
%     individuals.fitness(worestindex)=bestfitness;
%     
%     avgfitness=sum(individuals.fitness)/sizepop;
%     
%     trace=[trace;avgfitness bestfitness]; %记录每一代进化中最好的适应度和平均适应度
% 
% end
% %% 遗传算法结果分析 
%  figure
% [r, c]=size(trace);
% plot([1:r]',trace(:,2),'b--');
% title(['适应度曲线  ' '终止代数＝' num2str(maxgen)]);
% xlabel('进化代数');ylabel('适应度');
% legend('平均适应度','最佳适应度');
% x=bestchrom;
% 
% %% 把最优初始阀值权值赋予网络预测
% % %用遗传算法优化的BP网络进行值预测
% w1=x(1:inputnum*hiddennum);
% B1=x(inputnum*hiddennum+1:inputnum*hiddennum+hiddennum);
% 
% 
% net.iw{1,1}=reshape(w1,hiddennum,inputnum);
% net.lw{2,1}=reshape(w2,outputnum,hiddennum);
% net.b{1}=reshape(B1,hiddennum,1);
% net.b{2}=B2;
% 
% %% BP网络训练
% %网络进化参数
% net.trainParam.epochs=3000;
% net.trainParam.lr=0.1;
% net.trainParam.goal=0.001;
% 
% %网络训练
% [net,per2]=train(net,inputn,outputn);
% 
% %% BP网络预测
% %数据归一化
% inputn_test2=mapminmax('apply',input_test,inputps);
% an2=sim(net,inputn_test2);
% test_simu2=mapminmax('reverse',an2,outputps);
% 
% 
% Yn2=test_simu2; 
% Yn2=round(Yn2);
% figure                        %绘图
% plot(Yn2,'r*-')                %绘制预测值曲线
% hold on                       %继续绘图
% plot(output_test,'bo-')                  %实际值曲线
% legend('GABP预测值','实际值')      %图例
% wucha2=ones(1,79);             %GABP时预测误差
% for ii1=1:79
%     wucha2(ii1)=((Yn2(ii1)-output_test(ii1))/output_test(ii1));
% end
% figure
% plot(wucha2,'r*--')
% %% 画对比图
% figure                        %绘图
% plot(Yn,'r*-')                %绘制预测值曲线
% hold on                       %继续绘图
% plot(Yn2,'g^--')                %绘制预测值曲线
% hold on  
% plot(output_test,'bo-')                  %实际值曲线
% legend('BP预测值','GABP预测值','实际值')      %图例
% figure
% plot(wucha1,'b^-')
% hold on
% plot(wucha2,'r*--')
% legend('BP预测误差','GABP预测误差')      %图例
% % %% 数据存储
% % fid=fopen('shuchu.txt','w');
% % fprintf(fid,'%g\t',Yn);
% % fprintf(fid,'%g\t',Yn2);
% % fprintf(fid,'%g\t',wucha1);
% % fprintf(fid,'%g\t',wucha2);
% % fclose(fid);

