// 如果a%b=c，那么（a*k）%b=a%b+a%b+…+a%b=c+c+…+c=kc（k>0)
// 也就是说，如果一个除法的余数为c，那么被除数的k倍与除数相除的余数为kc

// 例五：三三数之剩二，五五数之剩三，七七数之剩二。问物几何？
// 即，一个整数除以三余二，除以五余三，除以七余二，求这个整数。
// 除以3余2和除以7余2的数可以写成21n+2。
// 21n+2除以5余3，要求21n除以5余1。
// 21n除以5余1，21除以5余1，要求n除以5余1（乘数之余等于余数之乘），则n最小取1。
// 所以满足“除以3余2，除以5余3，除以7余2”的最小的数是21×1+2=23。
// 标准解法：先从3和5、3和7、5和7的公倍数中相应地找出分别被7、5、3除均余1的较小数15、21、70 ( 注释:此步又称为求"模逆"运算,利用扩展欧几里得法并借助计算机编程可比较快速地求得.当然,对于很小的数,可以直接死算 )。即
// 15÷7=2……余1，
// 21÷5=4……余1，
// 70÷3=23……余1.
// 再用找到的三个较小数分别乘以所要求的数被7、5、3除所得的余数的积连加，
// 15×2+21×3+70×2=233. (将233处用i代替，用程序可以求出)
// 最后用和233除以3、5、7三个除数的最小公倍数.
// 233÷105=2……余23，
// 这个余数23就是合乎条件的最小数.

// 标准解法：先从3和5、3和7、5和7的公倍数中相应地找出分别被7、5、3除均余1的较小数15、21、70
// ( 注释:此步又称为求"模逆"运算,利用扩展欧几里得法并借助计算机编程可比较快速地求得.当然,对于很小的数,可以直接死算 )
// 扩展欧几里得
// 即求最小整数x，y，使得x*a+y*b=gcd(a,b)
// 因为欧几里得算法（辗转相除法）gcd(a,b)=gcd(b,a%b)
// 我们用欧几里得算法求得gcd(a,b)=1时，最后一轮一定是a'=1,b'=0
// 所以对应特解是a'=x'=1，b‘=0，y'可为任意值(可令其为0),注意这里a',b',x',y'都不是原来的a,b,x,y
// 而根据数学归纳法，当第i轮是b, a%b, 对应x,y，即对应方程为bx+(a-kb)y=1，即b(x-ky)+ay=1
// 则第i-1轮是a, b，对应x',y'，即x'=y， y'=x-ky。这样才能使得i层成立的同时，i-1层也同时成立


// 取i=2，第一轮a*x+b*y=1,第二轮b*x'+(a%b)*y"=1,即b*x'+(a-k*b)*y'=1,可化为a*y'+b*(x'-k*y')=1
// 所以x=y',y=x'-k*y',其中k=a/b


不会呀
// 5,x2=-1 3,y2=1-(5/3)*y1=2
// 3,x1=y=1 2,y1=0-(3/2)*1=-1
// 2,x=0 1,y=1-(2/1)*0=1
// 1,x'=1 0,y'=0

// #include<cstdio>
// #define ll long long
// //扩展欧几里得算法 
// void gcd(ll a,ll b,ll &d,ll &x,ll &y)
// {
//     if(b==0){
//         d=a;
//         x=1,y=0;
//     }
//     else{//else不能省略 
//         gcd(b,a%b,d,y,x);
//         y-=(a/b)*x;
//     }
// }
// //中国剩余定理 
// ll China(int n,ll *m,ll *a)
// {
//     ll M=1,d,y,x=0;
//     for(int i=0;i<n;i++) M*=m[i];
//     for(int i=0;i<n;i++){
//         ll w=M/m[i];
//         gcd(m[i],w,d,d,y);
//         x=(x+y*w*a[i])%M;
//     }
//     return (x+M)%M;
// }
// ll m[15],a[15];
// int main()
// {
//     int n;
//     scanf("%d",&n);
//     for(int i=0;i<n;i++)
//         scanf("%lld%lld",&m[i],&a[i]);
//     printf("%lld",China(n,m,a));
// }